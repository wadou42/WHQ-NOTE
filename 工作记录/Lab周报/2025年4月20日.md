### 测试指标问题
华为给的测试指标包括三个数据集，如果全部测试，大概需要22h...
![[hw给的测试指标.png]]

scnn简介：**SCANN​**​（Scalable Nearest Neighbors）是一种​大规模向量相似度搜索算法​*，属于​**​近似最近邻搜索​**​的范畴。

**​核心目标​**​：在超大规模数据集（如数十亿向量）中快速找到与查询向量最相似的Top-K个向量。暴力搜索能100%召回，但速度极慢，因此近似邻近搜索算法就通过舍弃一定的准确度，来提高搜索速度。

召回率：找到的 / 总的

条件：
1. 召回率越低速度越快 
2. 召回率大于80%比较有使用价值
所以我现在采用的是从 50 个查询参数中，筛选出4个，他们的召回率分散在0.8 - 1之间。分别计算四个参数下的加速比，再对加速比求均值。
![[Scann查询参数.png]]

### SRTuenr & Random测量结果
* SRTuenr 共30轮，只有一轮优于-O3 ，是1.04（后重复测量一次结果是1.014）
* Random 戒指目前搜索16轮，两轮优于-O3，最好的结果是1.030

![[SRTuenr_Random_scann.png]]

### 我们的方法
困难和解决办法
* scann是c++编译之后打包成Python包，导致我们的gperftools不可以用 --> 使用pygperftools （非官方，个人开发的）
* scann使用的bazel来构建，无法生成compile_commands.json --> hedron_compile_commands（非官方）
* scann 是模板密集型项目，大量的热点函数集中在.h文件，之前的提取函数信息的脚本不能用 --> 重写了一个新的脚本

目前从分析得到的热点来看，前三个热点函数都是运算符相关的
```c++
  SCANN_AVX2_INLINE IntelType operator*() const {
    static_assert(kNumRegisters == 1);
    return registers_[0];
  }


  SCANN_AVX2_INLINE Avx2& operator=(IntelType val) {
    static_assert(kNumRegisters == 1,
    "To intentionally perform register-wise broadcast, "
	"explicitly cast to an Avx2<T>");
    registers_[0] = val;
    return *this;

  }

static SCANN_AVX2_INLINE IntelType Add(IntelType a, IntelType b) {

    if constexpr (IsSameAny<T, float>()) {

      return _mm256_add_ps(a, b);

    }

    if constexpr (IsSameAny<T, double>()) {

      return _mm256_add_pd(a, b);

    }
    if constexpr (IsSameAny<T, int8_t, uint8_t>()) {
      return _mm256_add_epi8(a, b);
    }
    if constexpr (IsSameAny<T, int16_t, uint16_t>()) {return _mm256_add_epi16(a, b);}
    if constexpr (IsSameAny<T, int32_t, uint32_t>()) {
      return _mm256_add_epi32(a, b);
    }

    if constexpr (IsSameAny<T, int64_t, uint64_t>()) {
      return _mm256_add_epi64(a, b);
    }

    LOG(FATAL) << "Undefined";
  }
```
