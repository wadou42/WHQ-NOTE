## 方案上改进
1. 修改搜索空间：
	1. 取消对 **-O0** 的搜索，保持全部打开。
	2. **人工**阅读gcc官方文档，**筛选对性能无用的选项**。例如`-fcx-fortran-rules`选项，该选项强制 GCC 在复数乘除运算中遵循 ​​Fortran 标准​的语义规则（ISO/IEC 1539:1991），而非默认的 C/C++ 规则，对性能影响很小。
	3. 利用新的搜索空间收集数据，并按照方案中的方法，**寻找非关键优化标志**，进一步降低维度。
	4. 关于非01优化选项——看12步筛选后剩余选项的大小：如果比较小，可以在数据收集的时候就把01选项也收集了，然后预测阶段，把非01选项也加入到`<token>`，例如，对于优化选项`-fexcess-precision=[fast|standard|16]` ， 将`<-fexcess-precision=>` 加入token，进行预测。如果筛选后还是比较大，那就只在最后搜索的时候加上非01选项。
2. 单分类-->多分类 (挑战——预测的准确性是否够)
3. 搜索中加入非01选项
	1. 枚举类型，实现相对容易，可以通过约束的形式。例如，对于`-fstack-reuse=[all|named_vars|none]`这个优化选项，添加`-fstack-reuse=all -fstack-reuse=named_vars -fstack-reuse=none` 这么一组优化，保证三者不会被同时打开即可。
	2. 数值类型，具有挑战性，数值类型取值太广
4. 搜索中加入函数级调优工具。挑战——有些软件会出现爆内存的问题，例如`doris`， 目前解决方法是只对热点函数进行调优。
5. 在搜索的我过程中，对局部搜索产生的新的优化配置进行预测，如果预测值低于预期，直接跳过，重新变异。
## 实现上改进
1. 扩展数据集（额外的程序）
2. 将行号信息提取功能，从LLVM迁移到GCC
3. 将搜索功能，更改为多方法并行搜索（挑战——doris多个软件并行会导致爆内存）
